package localdns

import (
	"bufio"
	"fmt"
	"net"
	"os"
	"sort"
	"strings"
)

const hostsPath = "/etc/hosts"

/*

#      102.54.94.97     rhino.acme.com          # source server
#       38.25.63.10     x.acme.com              # x client host

127.0.0.1       localhost
*/
type Updater struct {
	OurTLD string // we replace any lines that end with this
}

// remove all lines for our TLD and replace them with new ones based on
// the provided mappings
func (u *Updater) Sync(mappings map[string]net.IP) error {
	existing, err := readLines(hostsPath)
	if err != nil {
		return fmt.Errorf("read lines: %s", err)
	}
	scrubbed := scrub(existing)

	toAdd := getLinesToAdd(mappings)

	final := append(scrubbed, toAdd...)

	err = atomicWriteLines(hostsPath, final)
	if err != nil {
		return fmt.Errorf("write lines: %s", err)
	}

	return nil
}

const signature = "generated by boshy virtual-ip-agent"

/*
   O_RDONLY int = syscall.O_RDONLY // open the file read-only.
   O_WRONLY int = syscall.O_WRONLY // open the file write-only.
   O_RDWR   int = syscall.O_RDWR   // open the file read-write.
   O_APPEND int = syscall.O_APPEND // append data to the file when writing.
   O_CREATE int = syscall.O_CREAT  // create a new file if none exists.
   O_EXCL   int = syscall.O_EXCL   // used with O_CREATE, file must not exist
   O_SYNC   int = syscall.O_SYNC   // open for synchronous I/O.
   O_TRUNC  int = syscall.O_TRUNC  // if possible, truncate file when opened.
*/
const tempFileFlags = os.O_RDWR | os.O_CREATE | os.O_EXCL

func atomicWriteLines(dstPath string, lines []string) error {
	tempPath := dstPath + ".new-boshy"
	file, err := os.OpenFile(tempPath, tempFileFlags, 0644)
	if err != nil {
		return fmt.Errorf("opening temp file: %s", err)
	}
	defer file.Close()
	for _, line := range lines {
		_, err := file.WriteString(line)
		if err != nil {
			return fmt.Errorf("writing to temp file: %s", err)
		}
	}
	file.Close()

	err = os.Rename(tempPath, dstPath)
	if err != nil {
		return fmt.Errorf("moving %q to %q: %s", tempPath, dstPath, err)
	}

	return nil
}

func getLinesToAdd(mappings map[string]net.IP) []string {
	lines := []string{}
	for hostname, ip := range mappings {
		lines = append(lines, fmt.Sprintf("%15s    %30s    # %s", ip.String(), hostname, signature))
	}
	sort.Strings(lines)

	return lines
}

func isOneOfOurs(line string) bool {
	return strings.Contains(line, signature)
}

func scrub(lines []string) []string {
	newLines := []string{}
	for _, line := range lines {
		if !isOneOfOurs(line) {
			newLines = append(newLines, line)
		}
	}

	return newLines
}

func readLines(path string) ([]string, error) {
	file, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	lines := []string{}
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		lines = append(lines, scanner.Text())
	}

	if err := scanner.Err(); err != nil {
		return nil, err
	}

	return lines, nil
}
